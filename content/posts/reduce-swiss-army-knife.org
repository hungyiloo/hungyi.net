#+TITLE: JavaScript's Reduce: A Swiss Army Knife for Arrays
#+DATE: 2020-09-28T12:09:03+08:00
#+TAGS[]: Code JavaScript Web Front-end Programming

There's a little method that's built into modern JavaScript that I've seen a lot of developers overlook, even when they're dealing with array or list aggregation. I suspect it's because of its abstract nature---much like other functional programming primitives---which doesn't exactly reveal any obvious use cases. But that's precisely why it's my favorite programming Swiss Army knife: you can do a lot more with it than you realise[fn:1].

[fn:1] And just like a Swiss Army knife, just because you /can/ do almost everything with it doesn't mean you /should/. Don't try to fell a tree with a Swiss Army knife; and don't try to use ~reduce~ to sort an array.

# more

Let me introduce you to my friend, [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce][~Array.prototype.reduce()~]].

* The Basics

There are 2 key ideas to understanding ~reduce()~:

1. It *loops* through every item in an array, one by one; and
2. It *accumulates* results (by calling a function that you define) and spits it out at the end as the return value.

To remind myself of these 2 core concepts, I usually use a lambda with the input parameters as ~acc~ (a.k.a. accumulated results) and ~curr~ (a.k.a. current item of the array that we're looping through). The names of the local variables help set the context in my head that I'm writing a reducer function. That said, feel free to name them however you please.

** The Classic Example
:PROPERTIES:
:CUSTOM_ID: summation-example
:END:

Summing a list of numbers is an example that's been repeated ad nauseam[fn:2] on every page of documentation ever written on [[https://en.wikipedia.org/wiki/Fold_(higher-order_function)][fold/reduce/accumulate/aggregate/compress/inject]]:

#+BEGIN_SRC js :results silent
// Calculate the sum of a list of numbers
[1,2,3,4].reduce((acc, curr) => acc + curr, 0); // => 10
#+END_SRC

In all seriousness, it's a great use case for ~reduce~. But because this example is so common, I'm sure many people think numerical summation or aggregation is the only strong suit of ~reduce~; I assure you it's not!

First let's take a detour to give you a taste of how fundamental the concept of ~reduce~ actually is.

[fn:2] I'm pretty sure a poor transistor dies a painful death each time a summation example is used to explain ~reduce()~.

* More Primitive Than Map, Filter, Includes & Find

You may be familiar with array functions such as [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map][~map~]], [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter][~filter~]], [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes][~includes~]] and [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find][~find~]] already. These are the bread and butter for list processing in JavaScript. I use them all the time, of course.

But did you know that you can implement them using ~reduce~? That's right. Because ~reduce~ is a more primitive and flexible building block for list processing, it can do everything that the friendlier functions can.

#+BEGIN_QUOTE
With the parts for an IKEA shelf, you can build that IKEA shelf. But with raw lumber, the right tools and some considerable effort, you can build almost anything.
#+END_QUOTE

Let me show you...

Implementing ~map~ using ~reduce~:
#+NAME: map-example
#+BEGIN_SRC js :results value code
const input = [1.618, 2.718, 3.141592653, 2.5029];

return {
  // Use map() to round a list of real numbers to the nearest integer
  roundedMap:
    input.map(x => Math.round(x)),

  // Do the same using reduce()
  roundedReduce:
    input.reduce((acc, curr) => [...acc, Math.round(curr)], [])
};
#+END_SRC

#+RESULTS: map-example
#+begin_src js
{ roundedMap: [ 2, 3, 3, 3 ], roundedReduce: [ 2, 3, 3, 3 ] }
#+end_src


Implementing ~filter~ using ~reduce~:
#+NAME: filter-example
#+BEGIN_SRC js :results value code
const input = [1.618, 2.718, 3.141592653, 2.5029];

return {
  // Use filter() to find all numbers above 2
  above2Filtered:
    input.filter(x => x > 2),

  // Do the same using reduce()
  above2Reduced:
    input.reduce((acc, curr) => curr > 2 ? [...acc, curr] : acc, [])
};
#+END_SRC

#+RESULTS: filter-example
#+begin_src js
{
  above2Filtered: [ 2.718, 3.141592653, 2.5029 ],
  above2Reduced: [ 2.718, 3.141592653, 2.5029 ]
}
#+end_src


Implementing ~includes~ using ~reduce~:
#+NAME: includes-example
#+BEGIN_SRC js :results value code
const input = [1.618, 2.718, 3.141592653, 2.5029];
const pi = 3.141592653;

return {
  // Use includes() to see if the collection contains pi
  containsPiIncludes:
    input.includes(pi),

  // Do the same using reduce()
  containsPiReduced:
    input.reduce((acc, curr) => acc || curr === pi, false)
};
#+END_SRC

#+RESULTS: includes-example
#+begin_src js
{ containsPiIncludes: true, containsPiReduced: true }
#+end_src


Implementing ~find~ using ~reduce~:
#+NAME: find-example
#+BEGIN_SRC js :results value code
const input = [1.618, 2.718, 3.141592653, 2.5029];

return {
  // Use find() to get the first item that is larger than 2
  firstAbove2Find:
    input.find(x => x > 2),

  // Do the same using reduce()
  firstAbove2Reduced:
    input.reduce((acc, curr) => acc || (curr > 2 ? curr : undefined), undefined)
};
#+END_SRC

#+RESULTS: find-example
#+begin_src js
{ firstAbove2Find: 2.718, firstAbove2Reduced: 2.718 }
#+end_src

Note that the above implementations are for demonstration purposes only. They're not as optimized and definitely less readable than their simpler counterparts. *Do not* blindly replace everything with ~reduce~.

However, if customizing the use of ~reduce~ above allows you to achieve something that you couldn't before, then by all means reduce away! Which brings us to...

* Things That Are Definitely Easier With Reduce

I'll show you a few creative uses for ~reduce~ that you might not have thought of, but this is by no means an exhaustive list. ~reduce~ is too flexible of a tool to have a finite list of use cases.

As long as you have to solve a problem with a list or array, you should consider reduce (if there's no other readily-available way to do it).

** Example 1: Boolean Aggregation

Other than [[#summation-example][summation]] and basic repeated arithmetic, there are some other interesting examples of aggregation that aren't immediately obvious.

Have you ever had a list of boolean conditions and you want to check if they're all true?

#+BEGIN_SRC js :results silent
const conditions = [
  3 > 2,
  4 % 2 === 0,
  [] == false,
  '' == false,
  !!1,
  !!!null
];

conditions.reduce((acc, curr) => acc && curr, true); // => true
#+END_SRC

In fact you can define some useful boolean aggregators with reduce:

#+BEGIN_SRC js :results silent
// Returns true if all conditions are true (as above)
function all(conditions) {
  return conditions.reduce((acc, curr) => acc && curr, true);
}
all([false, true, false]);  // => false
all([false, false, false]); // => false
all([true, true, true]);    // => true

// Returns true if any conditions are true
function any(conditions) {
  return conditions.reduce((acc, curr) => acc || curr, false);
}
any([false, true, false]);  // => true
any([false, false, false]); // => false
any([true, true, true]);    // => true

// Returns true if none of the conditions are true
function none(conditions) {
  return !any(conditions);
}
none([false, true, false]);  // => false
none([false, false, false]); // => true
none([true, true, true]);    // => false
#+END_SRC

** Example 2: Key-value Pair Aggregation

Sometimes you'll find yourself with an array of key-value pairs that you would rather have as one single JavaScript object instead. There are several ways to do this[fn:3], but ~reduce~ can be really good, idiomatic choice.

#+BEGIN_SRC js :results value code
const pairs = [
  { 'key': 'apple',  'value': 5  },
  { 'key': 'orange', 'value': 3  },
  { 'key': 'banana', 'value': 10 }
];

return pairs.reduce((acc, curr) => ({...acc, [curr.key]: curr.value}), {});
#+END_SRC

#+RESULTS:
#+begin_src js
{ apple: 5, orange: 3, banana: 10 }
#+end_src

[fn:3] If your data is in the right format, you can use ~Object.fromEntries()~. If it isn't in the right format, you can ~map~ it into the right format beforehand, but by then you might as well use ~reduce~ and get it done in one step. You might also consider ~new Map(pairs)~ if you're using the object as a dictionary-like lookup.

** Example 3: Cumulative Mapping

The accumulator pattern that ~reduce~ uses makes it intuitive to do cumulative sums, since you have immediate access to the accumulated data at each step. You also have easy access to the loop index (declared as ~i~ below).

#+BEGIN_SRC js :results value code
const input = [1,2,3,4,5,6,7,8,9,10];
return input.reduce((acc, curr, i) => [
  ...acc,
  i === 0 ? curr : acc[i-1] + curr
], []);
#+END_SRC

#+RESULTS:
#+begin_src js
[
   1,  3,  6, 10, 15,
  21, 28, 36, 45, 55
]
#+end_src

** Bonus Example: Redux-style Actions and Reducers

I'm pretty sure the idea of redux reducers came from the general concept of functional reduction. In fact, it would be correct to call the lambda function inside the ~reduce~ examples above as "reducers", since that function's job is to do the reducing.

When you reduce over some actions, you're essentially looping over them and accumulating their effects on some application state. Here's a toy calculator that follows this pattern.

#+BEGIN_SRC js :results value code
const actionTypes = {
  ADD:      0,
  SUBTRACT: 1,
  DIVIDE:   2,
  MULTIPLY: 3
};
const actions =  [
  { type: actionTypes.ADD,      payload: 5  },
  { type: actionTypes.SUBTRACT, payload: 1  },
  { type: actionTypes.MULTIPLY, payload: 8  },
  { type: actionTypes.MULTIPLY, payload: 32 },
  { type: actionTypes.SUBTRACT, payload: 24 },
  { type: actionTypes.DIVIDE,   payload: 5  },
  { type: actionTypes.ADD,      payload: 2  },
  { type: actionTypes.MULTIPLY, payload: 10 },
];
const initialState = [0];
return actions.reduce(
  (state, action, i) => {
    switch (action.type) {
      case actionTypes.ADD:
        return [...state, state[i] + action.payload];
      case actionTypes.SUBTRACT:
        return [...state, state[i] - action.payload];
      case actionTypes.DIVIDE:
        return [...state, state[i] / action.payload];
      case actionTypes.MULTIPLY:
        return [...state, state[i] * action.payload];
    }
  },
  initialState
);
#+END_SRC

#+RESULTS:
#+begin_src js
[
     0,    5,   4,  32,
  1024, 1000, 200, 202,
  2020
]
#+end_src

* A New Tool for Your Tool-belt

I hope I've shown that ~reduce~ is worth the effort to consider when dealing with lists and arrays, especially when none of the existing array functions do exactly what you want.

It's a primitive tool that can be a little mind-bending at first---but if you give it a little time, it can pay you back with its flexibility and elegance, allowing you to use one generic software pattern to solve many different types of problems.
